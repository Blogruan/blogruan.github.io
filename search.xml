<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021王道《数据结构》代码</title>
      <link href="/2020/06/26/2021%E7%8E%8B%E9%81%93%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%BB%A3%E7%A0%81/"/>
      <url>/2020/06/26/2021%E7%8E%8B%E9%81%93%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><audio controls="" preload="" __idm_id__="269361153">  <source    src="http://music.163.com/song/media/outer/url?id=547282061.mp3"    type="audio/mp3"  />  Your browser does not support the audio tag.</audio><h1 id="2021王道《数据结构》代码"><a href="#2021王道《数据结构》代码" class="headerlink" title="2021王道《数据结构》代码:"></a>2021王道《数据结构》代码:</h1><h2 id="第二章线性表"><a href="#第二章线性表" class="headerlink" title="第二章线性表:"></a>第二章线性表:</h2><h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h3><blockquote><p><strong>1.循序表定义</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#静态分配</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#动态分配</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//指示动态分配数组指针</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize,length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="meta">#c的初始动态分配语句为：</span></span><br><span class="line">L.data=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*InitSize);</span><br><span class="line"><span class="meta">#c++的初始动态分配语句:</span></span><br><span class="line">L.data=<span class="keyword">new</span> ElemType[InitSize];</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>2.<strong>从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。</strong></p><blockquote><p><strong>算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填空出的原最小值元素的位置。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_Min</span><span class="params">(sqList &amp;L, ElemType &amp;value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除循序表L中最小元素终点，并通过引用型参数value返回其值</span></span><br><span class="line">    <span class="comment">//若删除成功，则返回true;否则返回false</span></span><br><span class="line">    <span class="comment">//判断表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]&lt;value)&#123;</span><br><span class="line">            value=L.data[i];</span><br><span class="line">            pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//空出位置由最后一个元素填补</span></span><br><span class="line">    L.data[pos]=L.data[L.length<span class="number">-1</span>];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>3.设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O（1）。</strong></p><blockquote><p><strong>算法思想：扫描顺序表L的前半部分元素，对于元素L.data[i]（0&lt;=i&lt;L.length/2），将其与后半部分的对应元素L.data[L.length-i-1]进行交换。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//辅助变量</span></span><br><span class="line">    Elemtype temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//交换L.data[i]与L.data[L.length-i-1]</span></span><br><span class="line">        temp=L.data[i];</span><br><span class="line">        L.data[i]=L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">        L.data[L.length-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>4.<strong>对长度为n的顺序表L，编写一个时间复杂度为O(m）、空间复杂度为O（1）的算法，该算法删除线性表中所有值为x的数据元素。</strong></p><blockquote><p><strong>解法一：用k记录顺序表L中不等于x的元素个数（即需要保存的元素个数），边扫描L边统计k，并将不等于x的元素向前移动k个位置，最后修改L的长度</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_x_1</span><span class="params">(SqList &amp;L,Elemtype x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//本算法实现删除顺序表L中所有值为x的数据元素</span></span><br><span class="line">    <span class="comment">//记录值不等于x的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]!=x)&#123;</span><br><span class="line">            L.data[x]=L.data[i];</span><br><span class="line">            <span class="comment">//不等于x的元素的值增1</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        L.length=k;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p><strong>解法二：用k记录顺序表L中等于x的元素个数，边扫描L边统计k，并将不等于x的元素前移k个位置，最后修改L的长度。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_x_2</span><span class="params">(SqList &amp;L,Elemtype x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//记录k值等于x的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;L.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]==x)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//当前元素前移k个位置</span></span><br><span class="line">            L.data[i-k]=L.data[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=L.length-k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>5.从有序顺序表中删除其值在给定值s与t之间（要求s&lt;t）的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行。</strong></p><blockquote><p><strong>算法思想：先寻找值大于等于s的第一个元素（第一个删除的元素），然后寻找值大于t的第一个元素（最后一个删除的元素的下一个元素），要将这段元素删除，只需直接将后面的元素前移</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_s_t2</span><span class="params">(SqList &amp;L,Elemtype s,Elemtype t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除有序顺序表L中值在给定值s与t之间的所有元素</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;=t||L.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//寻找值大于等于s的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length&amp;&amp;L.data[i]&lt;s;i++);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=L.length)</span><br><span class="line">        <span class="comment">//所有元素值均小于s,返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//寻找值大于t的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;L.length&amp;&amp;L.data[j]&lt;=t;j++);</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;L.length;i++,j++)</span><br><span class="line">        <span class="comment">//前移，填补被删元素位置</span></span><br><span class="line">        L.data[i]=L.data[j];</span><br><span class="line">    L.length=i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>6.从顺序表中删除其值在给定值s与t之间（包含s和t，要求s&lt;t）的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行</strong></p><blockquote><p><strong>算法思想:从前向后扫描顺序表L,用k记录下元素值在s到t之间元素的个数(初始时k=0).对于当前扫描的元素,若其值不在s到t之间,则前移k个位置;否则执行k++.由于这样每个不在s到t之间的元素仅移动一次,所以算法效率高.</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_s_t</span><span class="params">(SqList &amp;L,ElemType s,ElemType t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除顺序表L中值在给定值s与t之间(要求s&lt;t)的所有元素</span></span><br><span class="line">    <span class="keyword">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>||s&gt;=t)</span><br><span class="line">        <span class="comment">//线性表为空或s,t不合法，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]&gt;=s&amp;&amp;L.data[i]&lt;=t)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//当前元素前移k个位置</span></span><br><span class="line">         L.data[i-k]=L.data[i];</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="comment">//长度减小</span></span><br><span class="line">    L.length-=k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>7.从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同</strong></p><blockquote><p><strong>算法思想:注意是有序顺序表,值相同的元素一定在连续的位置上,用类似于直接插入排序的思想,初始时将第一个元素视为非重复的有序表.之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同,若相同则继续向后判断,若不同则插入到前面的非重复有序表的最后,直至判断到表尾为止.</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Same</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//i存储第一个不相同的元素，j为工作指针</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">1</span>;j&lt;L.length;j++)</span><br><span class="line">        <span class="comment">//查找下一个与上个元素值不同的元素</span></span><br><span class="line">        <span class="keyword">if</span>(L.data[i]!=L.data[j])</span><br><span class="line">            <span class="comment">//找到后，将元素前移</span></span><br><span class="line">            L.data[++i]=L.data[j];</span><br><span class="line"> L.length=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>8.将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。</strong></p><blockquote><p><strong>算法思想:首先,按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中.然后,看哪个表还有剩余,将剩下的部分加到新的顺序表后面.</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(SqList &amp;A,SqList &amp;B,SqList &amp;C)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将有序顺序表A与B合并为一个新的有序顺序表C</span></span><br><span class="line">    <span class="comment">//大于顺序表最大长度</span></span><br><span class="line">    <span class="keyword">if</span>(A.length+B.length&gt;C.maxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环，两两比较，小者存入结果表</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.length&amp;&amp;j&lt;B.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.data[i]&lt;=B.data[j])</span><br><span class="line">            C.data[k++]=A.data[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C.data[k++]=B.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还剩一个没有比较完的顺序表</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.length)</span><br><span class="line">        C.data[k++]=A.data[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B.length)</span><br><span class="line">        C.data[k++]=B.data[j++];</span><br><span class="line">    C.length=k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>9.已知在一维数组A[m+n]中依次存放两个线性表（a1,a2,a3,…,am）和（b1,b2,b3,…,bn）。试编写一个函数，将数组中两个顺序表的位置互换，即将（b1,b2,b3,…,bn）放在（a1,a2,a3,…,am)的前面。</strong></p><blockquote><p><strong>算法思想:先将数组A[m+n]中的全部元素(a1,a2a3…,am,b1,b2,b3,…,bn)原地逆置为(bn,bn-1, bn-2,….,b1,am,am-1,am-2, ….,a1),再对前n个元素和后m个元素分别使用逆置算法,即可得到(b1,b2, b3,…,bn、a1,a2,a3,…,am),从而实现顺序表的位置互换.</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(DataType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//逆转(aleft,aleft+1,aleft+2...,aright)为(aright,aright-1,...,aleft)</span></span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right||right&gt;=arraySize)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mid-left;i++)&#123;</span><br><span class="line">        Datatype temp=A[left+i];</span><br><span class="line">        A[left+i]=A[right-i];</span><br><span class="line">        A[right-i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(DataType A[],<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数组A[m+n]中，从0到m-1存放顺序表(a1,a2,a3,...,am),从m到m+n-1存放顺序表(b1,b2,b3,...,bn).算法将这两个表的位置互换</span></span><br><span class="line">    Reverse(A,<span class="number">0</span>,m+n<span class="number">-1</span>,arraySize);</span><br><span class="line">    Reverse(A,<span class="number">0</span>,n<span class="number">-1</span>,arraySize);</span><br><span class="line">    Reverse(A,n,m+n<span class="number">-1</span>,arraySize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>10.线性表(a1,a2,a3，…，an）中的元素递增有序且按顺序存储于计算机内。要求设计一算法，完成用最少时间在表中查找数值为x的元素，若找到则将其与后继元素位置相交换，若找不到则将其插入表中并使表中元素仍递增有序</strong></p><blockquote><p><strong>算法思想:顺序存储的线性表递增有序,可以顺序査找,也可以折半査找.题目要求”用最少的时间在表中查找数值为x的元素”,这里应使用折半查找法</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchExchangeInsert</span><span class="params">(ElemType A[],ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//low和high指向顺序表下届和上届的下标</span></span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>;hight=n<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        <span class="comment">//找中间位置</span></span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//找到x,退出while循环</span></span><br><span class="line">        <span class="keyword">if</span>(A[mid]==x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//到中点mid的右半部去查</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;x) low=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//到中点mid的左半部去查</span></span><br><span class="line">        <span class="keyword">else</span> high=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="comment">//下面两个if语句只会执行一个</span></span><br><span class="line">    <span class="keyword">if</span>(A[mid]==x&amp;&amp;mid!=n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//若最后一个元素与x相等,则不存在与其后继交换的操作</span></span><br><span class="line">        t=A[mid];</span><br><span class="line">        A[mid]=A[mid+<span class="number">1</span>];</span><br><span class="line">        A[mid+<span class="number">1</span>]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;high;i--) A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">        A[i+<span class="number">1</span>]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>11.<strong>【2010统考真题】设将n（n&gt;1）个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p（0&lt;p&lt;n）个位置，即将R中的数据由（X0,X1…，Xn-1变换为（Xp,Xp+1,…，Xn-1,X0,X1,…,Xp-1）。要求：</strong></p><p><strong>1）给出算法的基本设计思想。</strong></p><p><strong>2）根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</strong></p><p><strong>3）说明你所设计算法的时间复杂度和空间复杂度。</strong></p><blockquote><p><strong>1)算法的基本设计思想:可将这个问题视为把数组ab转换成数组ba(a代表数组的前p个元素,b代表数组中余下的n-p个元素),先将a逆置得到a^(-1)<em>b,再将b逆置得到a^(-1)</em>b^(-1),最后将整个a-1b-1逆置得到(a^(-1)*b^(-1))^(-1)=ba.设 Reverse函数执行将数组元素逆置的操作,对abcdefgh向左循环移动3(p=3)个位置的过程如下：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reverse(<span class="number">0</span>,p<span class="number">-1</span>)得到 cbadefgh;</span><br><span class="line">Reverse(p,n<span class="number">-1</span>)得到 cbahgfed;</span><br><span class="line">Reverse(<span class="number">0</span>,n<span class="number">-1</span>)得到 defghabc;</span><br></pre></td></tr></table></figure><p><strong>2)使用C语言描述算法如下:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(to-from+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        temp=R[from+i];</span><br><span class="line">        R[from+i]=R[to-i];</span><br><span class="line">        R[to-i]=temp;</span><br><span class="line">    &#125;<span class="comment">//Reverse</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Converse</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    Reverse(R,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">    Reverse(R,p,n<span class="number">-1</span>);</span><br><span class="line">    Reverse(R,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3)上述算法中三个 Reverse函数的时间复杂度分别为O（p/2)、O((n-p)/2)和O(n/2),故所设计的算法的时间复杂度为O(n),空间复杂度为O(1)</strong></p><p><strong>另解,借助辅助数组来实现.算法思想:创建大小为p的辅助数组S,将R中前p个整数依次暂存在S中,同时将R中后n-p个整数左移,然后将S中暂存的p个数依次放回到R中的后续单元.时间复杂度为O(n),空间复杂度为O(p)</strong></p></blockquote></blockquote><blockquote><p><strong>12.【2011统考真题】一个长度为L（L&gt;=1）的升序序列S，处在第「L/2]个位置的数称为S的中位数。例如，若序列S1=（11，13,15,17,19），则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=（2,4,6,8,20），则S1和S2的中位数是11现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求:</strong></p><blockquote><p><strong>1）给出算法的基本设计思想</strong></p><p><strong>2）根据设计思想，采用C或++或Java语言描述算法，关键之处给出注释。</strong></p><p><strong>3）说明你所设计算法的时间复杂度和空间复杂度</strong></p><p><strong>1)算法的基本设计思想如下：</strong></p><p><strong>分别求两个升序序列A、B的中位数,设为a和b,求序列A、B的中位数过程如下:</strong></p><p><strong>① a=b,则a或b即为所求中位数,算法结束.</strong></p><p><strong>② a&lt;b,则舍弃序列A中较小的一半,同时舍弃序列B中较大的一半,要求两次舍弃的长度相等</strong></p><p><strong>③若a&gt;b,则舍弃序列A中较大的一半,同时舍弃序列B中较小的一半,要求两次舍弃的长度相等，在保留的两个升序序列中,重复过程①、②、③,直到两个序列中均只含一个元素时为止,较小者即为所求的中位数.</strong></p><p><strong>2）本题代码如下：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">M_Search</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1=<span class="number">0</span>,d1=n<span class="number">-1</span>,m1,s2=<span class="number">0</span>,d2=n<span class="number">-1</span>,m2;</span><br><span class="line">    <span class="comment">//分别表示序列A和B的首位数，末位数和中位数</span></span><br><span class="line">    <span class="keyword">while</span>(s1!=d1||s2!=d2)&#123;</span><br><span class="line">        m1=(s1+d1)/<span class="number">2</span>;</span><br><span class="line">        m2=(s2+d2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[m1]==B[m2])</span><br><span class="line">            <span class="comment">//满足条件1</span></span><br><span class="line">            <span class="keyword">return</span> A[m1];</span><br><span class="line">        <span class="keyword">if</span>(A[m1]&lt;B[m2])&#123;</span><br><span class="line">            <span class="comment">//满足条件2</span></span><br><span class="line">            <span class="comment">//若元素个数为奇数</span></span><br><span class="line">            <span class="keyword">if</span>((s1+d1)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//舍弃A中间点以前的部分且保留中间点</span></span><br><span class="line">                s1=m1;</span><br><span class="line">                <span class="comment">//舍弃B中间点以后部分且保留中间点</span></span><br><span class="line">                d2=m2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//元素个数为偶数</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//舍弃中间点及中间点以前部分</span></span><br><span class="line">                s1=m1+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//舍弃B中间点以后的部分且保留中间点</span></span><br><span class="line">                d2=m2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//满足条件3</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//若元素个数为奇数</span></span><br><span class="line">            <span class="keyword">if</span>((s2+d2)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//舍弃A中间点以后的部分且保留中间点</span></span><br><span class="line">                d1=m1;</span><br><span class="line">                <span class="comment">//舍弃B中间点以前的部分且保留中间点</span></span><br><span class="line">                s2=m2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//元素个数为偶数</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//舍弃A中间点以后的部分且保留中间点</span></span><br><span class="line">                d1=m1;</span><br><span class="line">                <span class="comment">//舍弃B中间点及中间点以前部分</span></span><br><span class="line">                s2=m2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[s1]&lt;B[s2]? A[s1]:B[s2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）算法的时间复杂度为O（log2n),空间复杂度为O(1).</strong></p></blockquote></blockquote><blockquote><p><strong>13.【2013统考真题】上知一个整数序列A=（a0,a1…，an-1），其中0≤ai&lt;n（0≤1&lt;n）若存在ap1=ap2=…=apm=x且m&gt;n/2（0≤pk&lt;n，1≤k≤m）则称x为A的主元素。例如A=（0,5,5,3,5,7,5,5），则5为主元素；又如A=（0,5,5,3,5,1,5,7），则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1.要求：</strong></p><blockquote><p><strong>1）给出算法的基本设计思想</strong></p><p><strong>2）根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</strong></p><p><strong>3）说明你所设计算法的时间复杂度和空间复杂度。</strong></p><p><strong>1）给出算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记出一个可能成为主元素的元素Num。然后重新计数，确认Num是否是主元素。</strong></p><p><strong>算法可分为以下两步：</strong></p><p><strong>① 取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1;当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。</strong></p><p><strong>② 判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大于n/2，则为主元素；否则，序列中不存在主元素</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Majority</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> <span class="comment">//c用来保存候选主元素,count用来计数</span></span><br><span class="line"> <span class="keyword">int</span> i,c,count=<span class="number">1</span>;</span><br><span class="line"> <span class="comment">//设置A[0]为候选主元素</span></span><br><span class="line"> c=A[<span class="number">0</span>];</span><br><span class="line"> <span class="comment">//查找候选主元素</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">     <span class="keyword">if</span>(A[i]==c)</span><br><span class="line">         <span class="comment">//对A中的候选主元素计数</span></span><br><span class="line">         count++;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">//处理不是候选主元素的情况</span></span><br><span class="line">         <span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">             count--;</span><br><span class="line"> <span class="comment">//更换候选主元素,重新计数</span></span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">             c=A[i];</span><br><span class="line">             count=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">     <span class="comment">//统计候选主元素的实际出现次数</span></span><br><span class="line">     <span class="keyword">for</span>(i=count=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">         <span class="keyword">if</span>(A[i]==c)</span><br><span class="line">             count++;</span><br><span class="line"> <span class="comment">//确认候选主元素</span></span><br><span class="line"> <span class="keyword">if</span>(count&gt;n/<span class="number">2</span>) <span class="keyword">return</span> c;</span><br><span class="line"> <span class="comment">//不存在主元素</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）实现的程序的时间复杂度为O（n），空间复杂度为O（1）</strong></p></blockquote></blockquote><blockquote><p><strong>14.【2018统考真题】给定一个含n（n≥1）个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5,3,2,3}中未出现的最小正整数是1；数组{1,2,3}中未出现的最小正整数是4.要求</strong></p><p><strong>1）给出算法的基本设计思想</strong></p><p><strong>2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释</strong></p><p><strong>3）说明你所设计算法的时间复杂度和空间复杂度。</strong></p><blockquote><p><strong>1）要求在时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的数组B[n]，用来记录A中是否出现了1n中的正整数，B[0]对应正整数1，B[n-1]对应正整数n，初始化B中全部为0.由于A中含有n个整数，因此可能返回的值是1n+1，当A中n个数恰好为1n时返回n+1。当数组A中出现了小于等于0或大于n的值时，会导致1n中出现空余位置，返回结果必然在1~n中，因此对于A中出现了小于等于0或大于n的值可以不采取任何操作。</strong></p></blockquote><blockquote><p><strong>经过以上分析可以得出算法流程：从A[0]开始遍历A，若0&lt;A[i]&lt;=n，则令B[A[i]-1]=1;否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i]==0的下标i，返回i+1即为结果，此时说明A中未出现的最小正整数在1~n之间。若B[i]全部不为0，返回i+1（跳出循环时i=n,i+1等于n+1），此时说明A中未出现的最小正整数是n+1。</strong></p><p><strong>2）算法实现：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMissMin</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="keyword">int</span> i,*B;</span><br><span class="line">    <span class="comment">//分配空间</span></span><br><span class="line">    B=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    <span class="comment">//赋初值为0</span></span><br><span class="line">    <span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="comment">//若A[i]的值介于1~n,则标记数组B</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;<span class="number">0</span>&amp;&amp;A[i]&lt;=n)</span><br><span class="line">            B[A[i]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//扫描数组B,找到目标值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(B[i]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）时间复杂度：遍历A一次，遍历B一次，两次循环内操作步骤为O（1）量级，因此时间复杂度为O（n）。空间复杂度：额外分配了B[n]，空间复杂 度为O（n）</strong></p></blockquote></blockquote><h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a><strong>线性表的链式表示</strong></h3><blockquote><p><strong>1.单链表的定义</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="comment">//指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>2.单链表的基本操作</strong></p><blockquote><p><strong>2.1采用头插法建立单链表</strong></p><img src= https://gitee.com/ruanio/blog/raw/master/img/loading.gif data-src="https://i.loli.net/2020/07/01/GzWwvEsn7B3cA6t.png" alt="头插法" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆向建立单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"> LNode *s; <span class="keyword">int</span> x;</span><br><span class="line"> <span class="comment">//创建头结点</span></span><br><span class="line"> L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"> <span class="comment">//初始为空链表</span></span><br><span class="line"> L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="comment">//输入结点的值</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"> <span class="comment">//输入9999表示结束</span></span><br><span class="line"> <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">     <span class="comment">//创建新的结点</span></span><br><span class="line">     s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">     s-&gt;data=x;</span><br><span class="line">     s-&gt;next=L-&gt;next;</span><br><span class="line">     L-&gt;next=s;</span><br><span class="line">     <span class="comment">//将新结点插入表中,L为头指针</span></span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2采用尾插法建立单链表</strong></p><img src= https://gitee.com/ruanio/blog/raw/master/img/loading.gif data-src="https://i.loli.net/2020/07/01/MAi79ylGst4IwS3.png" alt="尾插法" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正向建立单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"> <span class="comment">//设元素类型为整形</span></span><br><span class="line"> <span class="keyword">int</span> x;</span><br><span class="line"> L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"> <span class="comment">//r为表尾指针</span></span><br><span class="line"> LNode *s,*r=L;</span><br><span class="line"> <span class="comment">//输入结点的值</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"> <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">     s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">     s-&gt;data=x;</span><br><span class="line">     r-&gt;next=s;</span><br><span class="line">     <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">     r=s;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//尾结点指针置空</span></span><br><span class="line"> r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3按序号查找结点值</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//计数，初始值为1</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//头结点指针赋给p</span></span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="comment">//若i等于0，则返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//若i无效，则返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//从第1个结点开始找,查找第i个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回第i个结点的指针，若i大于表长则返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.4按值查找表结点</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L;ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="comment">//从第一个结点开始查找data域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
